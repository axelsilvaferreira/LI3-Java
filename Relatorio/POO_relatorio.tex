\documentclass[a4paper,10pt]{article}
\usepackage{a4wide}
\usepackage[T1]{fontenc}
\usepackage[applemac]{inputenc} 
\usepackage[portuguese,english]{babel} 
\usepackage{graphicx}
\usepackage{eso-pic} % marca de água para logos
\usepackage{fancyhdr}% logo para cabecalhos
\usepackage{hyperref} % Utilizacao de links
\usepackage{caption}
\usepackage{subcaption}

%------------------- Comandos ---------------------%
\renewcommand{\headheight}{0.6in}
\setlength{\headwidth}{\textwidth}
\fancyhead[L]{}% empty left
\fancyhead[L]{ % right
   \includegraphics[height=0.53in]{/Users/axelferreira/Dropbox/uMinho/relatorio/logo-ee.jpg} % LOGO Cabeçalhho
}
\pagestyle{fancy}

\setlength{\unitlength}{1mm}
\newcommand\BackgroundPic[3]{
\put(#2,#3){\parbox[b][\paperheight]{\paperwidth}{
\vfill
\centering
\includegraphics{#1}
\vfill
}}}

%-------------------- Documento ------------------%
\begin{document}
%--- Logo Capa ---%
\AddToShipoutPicture*{\BackgroundPic{/Users/axelferreira/Dropbox/uMinho/relatorio/logo_eeng}{-210}{370}} % LOGO CAPA

%\includegraphics[width=100pt]{axel.jpg}
%\AddToShipoutPicture*{\BackgroundPic{axel.jpg[30pt]}{150}{-150}} % LOGO CAPA

\title{Projecto Java de Laboratório de Informática\\Relatório}
\author{Discentes:\\Axel Ferreira - a53064\\João Rua - a41841\\ \vspace{5pt}\\ Docentes:\\ F. Mário Martins\\João Miguel Fernandes\\João Luís Sobral  \vspace{20pt}}
\date{\today}

\maketitle
\vspace{40pt}

\centering

%\begin{figure}[h]
%\section{Grupo}
	\centering \huge Grupo\\ \vspace{20pt}
	\vspace{20pt}
	\begin{figure}[h]
	%	\hspace{20pt}
	        \begin{subfigure}[b]{0.30\textwidth}
	                \centering
	                \includegraphics[width=\textwidth]{axel.jpg}
		       \caption{nome : Axel Ferreira \\
				    número : 53064 \\
				    mail : axelferreira@me.com \\}
	                \label{fig:gull}
	        \end{subfigure}
		\hfill
		  \begin{subfigure}[b]{0.30\textwidth}
	                \centering
	                \includegraphics[width=\textwidth]{joao.jpg}
		       \caption{nome : João Rua \\
				    número : 41841 \\
				    mail : joaorua@gmail.com \\}
	                \label{fig:gull}
	        \end{subfigure}
		\hfill
	    %    \hspace{20pt}
	        %	        	\caption{Pictures of animals}\label{fig:animals}
	\end{figure}
%\end{figure}
\large
\newpage
\tableofcontents
%\newpage
%%%%%%%%%%%%%%%%%%%%  ABSTRACT  %%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
	
	Foi desenvolvido um programa no âmbito da U.C. de Laboratório de Informática III , capaz de utilizar o conteúdo processado pelo pelo anterior programa desenvolvido em C, também nesta UC, capaz de ler um ficheiro contendo um conjunto de autores e respetivos co-autores, e responder a alguns queries interativos sobre estes dados. Estes dados de autorias, e co-autorias são retirados do website \href{www.dblp.org}{\underline{DBLP}}.
		
\end{abstract}

%%%%%%%%%%%%%%%%%%%%  INTRODUCAO  %%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}
	No âmbito da unidade curricular Laboratórios de Informática III foi proposta a realização de um projeto que dá continuidade ao projeto anteriormente desenvolvido em C nesta mesma UC. Este novo projeto conta com essencialmente duas partes.
	A primeira diz respeito á leitura de dados de memória secundária e população de estruturas de dados em memória central, gravação destas estruturas de dados em memória persistente em modo binário, bem como a criação de alguns queries de forma a permitir uma consulta interativa aos dados.
	Desenvolveram-se ainda alguns métodos que permitem consultas sobre as estruturas de dados.
	A Segunda parte prevê o teste de performance do código e respetivas estruturas de dados criados na 1ª parte, relativamente a estruturas de dados alternativas.
	De forma a facilitar esta segunda parte, o grupo teve o cuidado de criar uma interface cada vez que foi utilizada uma estrutura de dados do Java.Collections, de forma a permitir alterar as estruturas utilizadas alterando apenas, e se necessário, esta interface.
	
		
	%%%%%%%%%%%%%%%%%%     ESTRUTUA DO RELATORIO     %%%%%%%%%%%%%%
	\subsection{Estrutura do Relatório}
		Este relatório inicia-se com uma capa, incluindo o título do projeto, a data, a identificação dos autores e da equipa docente que acompanhou o projeto. Segue-se o Índice, o Abstract que resume o projeto, a Introdução ao mesmo (onde se explicita o objetivo a atingir) e a Estrutura do Relatório. 
		
	
	%%%%   <---------------CONTINUAR
		%%% BLA BLA BLA BLA BLA
		%O Desenvolvimento tem como secções os tipos e estruturas de dados, cada uma das tarefas Fase 1, Fase 2A e Fase 2B. Por fim apresentam-se a Conclusão e os anexos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%      ESTRUTURAS & TIPOS DE DADOS     %%%%%%%%%%%%%%%%
\section{Classes Criadas e Estruturas de Dados}
		%%%%%%%%%%%%%%%%%%     TIPOS DE DADOS     %%%%%%%%%%%%%%%%%
		\subsection{Classes Criadas}
		Na criação deste programa foram desenvolvidas as seguintes classes:
		\begin{itemize}
			\item Anos - Esta classe armazena toda a estrutura de dados, contém um Uma coleção (HashMap) com os os seguintes campos
				\begin{verbatim}
					private TreeMap<String,Ano> anos; 
				\end{verbatim}
			\item Ano - Classe criada para guardar o conteúdo de cada Ano, contém uma String com o nome do ano e um HashMap com os Autores
				\begin{verbatim}
					private String ano;
    					private HashMap<String,Autor> autores;
				\end{verbatim}
		\end{itemize}
		\subsection{Macros}	
		Estas macros foram utilizadas para facilitar a criação e manutenção do programa, bem como para facilitar a compreensão do mesmo. Desta forma, os seguintes tipos foram definidos.
			\begin{itemize} 
				\item TRUE 1 - Representa o valor boleano verdadeiro e corresponde ao valor 1 utilizado pelo compilador.
				\item FALSE 0 - Análogo ao anterior para o valor falso (0).
				\item MAX\_XXXX - Valores para inicialização de valores como dimensão máxima ou dimensão inicial de arrays ou buffers.
				\item DEBUG\_MODE X - X toma um valor inteiro de forma a activar vários níveis do modo de debugging, que permite mostrar informação respeitante ao debugging ( como pr. ex. mostrar printf() ), em que cada nível diz respeito a debugging de partes diferentes de cada módulo do programa.
				\item MAX\_FILE X - X representa o número máximo de ficheiros com que o módulo fread pode trabalhar em simultâneo. Este valor é alterado na interface.

			\end{itemize}
		
		%%%%%%%%%%%%%%%%%%     ESTRUTUAS DE DADOS     %%%%%%%%%%%%%%
		\subsection{Estruturas de Dados}
		
		\includegraphics[width=\textwidth]{Estrutura.jpg}
		A estrutura de dados escolhida para armazenar os dados processados foi um Array de Listas Ligadas. Inicialmente este array tinha 100 posições possíveis para anos, isto porque dado o contexto do problema seria suficiente(dado que a primeira publicação datava de 1936). Contudo foi redimensionado para 3000 posições, ocupando cerca de 24KB de memória, uma dimensão ainda assim razoável dado o contexto do problema, isto devido á existência, nos ficheiros de teste, de datas de publicações fictícias do ano 1300. 
		O ano corresponde ao índice do array, que é calculado retirando o ano inicial ao ano em questão e somando 1. O índice 0 foi reservado para manter contadores totais para facilitar a pesquisa eficiente por número de artigos.
		Cada nodo do array tem um apontador para uma lista ligada. Estas listas ligadas têm 2 inteiros um que guarda o \#Autores que publicaram, o outro o número de artigos.
		A razão pela qual esta estrutura foi escolhida deve-se á simplicidade de implementação bem como á vantagem em performance relativamente á utilização de apenas uma lista ligada.
		Sabendo que o acesso ao array é constante, e que os artigos se encontram relativamente bem distribuídos por ano. O acesso ás sub-listas ligadas de um determinado ano é constante. Sabendo também que a distribuição de artigos por número de autor se encontra entre as co-autorias de 1 a 20 elementos, conclui-se que esta lista nunca será muito grande, garantindo assim pouca penalização nos acessos á memória (relativamente a uma alternativa implementada apenas em listas ligadas). 
		
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     FASE 1     %%%%%%%%%%%%%%%%%%%%
\section{Fase 1}
		A primeira fase incidiu na criação de um programa capaz de ler um ficheiro	lista.txt, e para cada linha deste ficheiro, invocar um módulo separado "Parser" que abria e processava o ficheiro cujo nome correspondia á linha lida, armazenando os resultados estatísticos no próprio módulo. 
		Finalmente, no modulo main, era invocada uma função da interface do módulo parser que imprimia os ficheiros D e E com o respetivo conteúdo.
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     FASE 2A     %%%%%%%%%%%%%%%%%%%%
\section{Fase 2A}

		Nesta fase foi efetuado o refactoring e implementado o buffer dinâmico. Garantindo-se desta forma que o fluxo do programa é centrado no main e que o buffer tem sempre tamanho suficiente para ler uma linha.
		
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%     FASE 2B     %%%%%%%%%%%%%%%%%%%%%	
\section{Fase 2B}
		
		Para esta fase foi reservado o índice 0 do array de anos. Este índice contém um apontador para uma lista ligada de número de autores e número de artigos correspondentes, em tudo semelhante ás outras, com a particularidade desta lista conter o total de \#artigos para cada \#Autores sendo que a entrada com o \#Autores 0 tem o \#Artigos total de toda a estrutura.
		Foi também introduzido um primeiro nodo em cada lista com \#Autores 0, de forma a garantir um contador do total de artigos para um determinado ano, com o intuito de facilitar e tornar mais eficiente o o cálculo das percentagens bem como o intervalo de anos por \#Artigos para criação do Ficheiro G.
		O refactoring alterou o programa, garantindo que o fluxo do mesmo passava pelo main. Como á partida parece evidente, devia ter havido uma perda na performance uma vez que todo o conteúdo é transportado entre módulos através do main, em vez de ser acedido diretamente. Contudo e após medições de tempos conclui-se que houve um ganho ligeiro na performance.
		Dado que a estrutura não cresce muito em tamanho á medida que o input aumenta uma vez que são apenas incrementadas as variáveis já contidas na estrutra, o tempo de procura ou impressão do ficheiro G na estrutura para valores sucessivamente maiores do input é constante.
		\includegraphics[width=.5\textwidth]{terminal}\\
		
		% ANALISE DO TEMPO DE EXECUÇÂO MC - PC - CM

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     Modularidade     %%%%%%%%%%%%%%%%%%%%			
\section{Modularidade}
			Após a primeira entrega, de forma a garantir a ocultação de dados e da implementação, a abstração de dados, o encapsulamento e alguma independência contextual, a arquitetura do programa sofreu um processo de refactoring tendo sido reformulados e criados novos módulos. Em cada módulo, os dados foram declarados como "static" tendo sido criados interfaces para mediar o manuseamento dos mesmos. Isto garante independência contextual, ocultação da implementação e dos dados. Estas interfaces foram posteriormente incluídas no programa main de forma a garantir que todo o fluxo do programa é controlado pelo módulo main.
			é possível ver a nova arquitetura dos módulos no diagrama abaixo.
			\includegraphics[width=\textwidth]{Arquitetura.jpg}
			Toda a criação do programa, alteração e implementações experimentais foram feitas com recurso ao git com repositório no Github. O que permitiu a criação de branches para cada parte do projeto, bem como para experiências. \\
			\includegraphics[width=.5\textwidth]{branch.jpg}\\
			Para além disto também foi com recurso ao Git que foi possível a compilação de uma versão pré-refactoring para comparação da performance.
						
			\subsection{parser} O módulo Parser é responsável pelo parsing e validação de cada linha que lhe é passada. devolvendo uma estrutura Stats contendo a informação relevante da linha (nomes de autores, número de autores e ano da publicação) caso seja válida.
			
			\subsection{fread} O módulo fread (file read) é responsável pela abertura de ficheiros para leitura. Está preparado para trabalhar com um número de ficheiros máximo a definir na interface. Este módulo está preparado para trabalhar com múltiplos ficheiros simultaneamente devido a duas razões. A primeira é para permitir que este módulo possa trabalhar com o ficheiro lista.txt e com um ficheiro de revista ou conferencia em simultâneo. A segunda razão deve-se a inicialmente ter sido pensada a possibilidade de otimizar o programa através da criação de várias threads de forma a que cada ficheiro de revista ou conferência pudesse ser tratado num processo separado, implementando assim paralelismo. 
			Contudo no decorrer do projeto, e após medições te tempos de execução tanto no teste 5 (stress) como posteriormente no TESTE1\_FASE2, foi concluído que esta otimização era desnecessária tendo em conta o tempo que a implementação gastaria, bem como o pouco benefício (em tempo de execução) que traria. Esta conclusão é suportada pelo facto dos testes utilizados terem dimensões razoavelmente grandes e o tempo de execução nestes testes anda na ordem das décimas de segundo tal como nos testes mais simples.
			Inicialmente foi implementado um buffer de 1KB, tendo sido alterado posteriormente para um buffer dinâmico em que o tamaho inicial deste buffer é ligeiramente superior á dimensão da maioria do tamanho das entradas.
			
			\includegraphics[width=\textwidth]{grafo.jpg}
			
			\subsection{fwrite}
			Este módulo é semelhante ao anterior, difere apenas no propósito de escrever ficheiros.
			\subsection{F}
			O módulo F consiste na implementação da fase 2A, possui uma interface que é utilizada pelo módulo main de forma a inserir os dados relevantes que o main recebe através do módulo parser. O módulo F é responsável pela criação e gestão da estrutura de dados que permite posteriormente imprimir o ficheiro G.
			\subsection{main}
			Este módulo controla o fluxo do programa, fazendo a ponte entre os módulos anteriores. Nomeadamente faz um pedido de linha do ficheiro lista.txt ao modulo fread, para cada linha devolvida faz um novo pedido a esse módulo com o nome de cada ficheiro, sendo devolvida cada linha (entrada) deste último ficheiro. Posteriormente o main passa a linha obtida ao parser, de onde é devolvido um resultado que pode ser NULL sendo incrementado o contador de artigos rejeitados (static no main) ou uma estrutura com informação que é passada ao módulo F para inserção. Finalmente, quando todos os ficheiros contidos no ficheiro "lista.txt" forem processados, o módulo main dá ordem de impressão dos ficheiros D.txt, E.txt e G.csv aos respetivos módulos.
			
\section{Conclusão}
		
		A principal dificuldade que foi ultrapassada, nomeadamente na 2ª Fase, foi a implementação das estruturas de dados uma vez que a função de inserção não funcionava corretamente tendo sido re implementada numa versão recursiva correta. A dificuldade não ultrapassada devido, ao tempo despendido no processo de refactoring, resume-se á falta de tempo para implementação da estrutura de co-autoria. 

\section{Interface}
\begin{itemize}
	\item Parser
		\begin{verbatim}
		 /**
		 * Patses a Line 
		 * @param buffer the buffer containing the line to be parsed
		 * @param ty+he type of the line conference or jounal)
		 * @return Struct with all counters.
		 */
		Stats parseLine(char * buffer, char t);
		\end{verbatim}
		
	\item fread
		\begin{verbatim}
		 /**
		 * Initializes the control for the files
		 */
		void init_file_control();
		
		/**
		 * Opens a file.
		 * @return file index in control, or -1 if failed.
		 */
		int openFile(char * file_name, char * mode);
		
		/**
		 * Reads a line from a file growing the buffer as needed.
		 * @param a reference to the buffer reference.
		 * @param a reference for the size of the buffer.
		 * @param file index in control.
		 * @return 0 if success -1 otherwise.
		 */
		int dynamic_read_line(char** buf, int* size, int file);
		
		/**
		 * Closes a file.
		 * @param index of the file to be closed.
		 */
		void closeFile(int index);
		\end{verbatim}
	\item fwrite
		\begin{verbatim}
		/**
		 * This function outputs the number of rejected entries in each file to the "E.txt" file. If the file does not exist, it is created.
		 * @param int counter number of invalid entries in the file.
		 * @param char * fileN the name of the courent file.
		 */
		void imprimeE(int bool, int counter, char * file, char * path);

		/**
		 * This function creates the file "D.txt" and it's content. If the file alreaddy exists, it is rewritten.
		 * @param nRej the number of rejected entries
		 * @param nJou the number of Journals
		 * @param nCou the number of Counferences
		 * @param path the path of the file to be written to.
		 */
		void imprimeD(int nRej, int nJou, int nCou, char * path);
		\end{verbatim}
	\item F
		\begin{verbatim}
		/**
		 * Adds data to the structure.
		 * @return returns a pointer to a structure with the linked list
		 */
		struct sList * addList();
		
		/**
		 * This function creates the file "G.csv" and it's content. If the file alreaddy exists it is rewritten.
		 * @param bool if it's first time opens in "w" mode else in "a".
		 */
		int imprimeG();
		\end{verbatim}
		
\end{itemize}		
		
	
\end{document}