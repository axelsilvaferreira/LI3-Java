\documentclass[a4paper,10pt]{article}
\usepackage{a4wide}
\usepackage[T1]{fontenc}
\usepackage[applemac]{inputenc} 
\usepackage[portuguese,english]{babel} 
\usepackage{graphicx}
\usepackage{eso-pic} % marca de água para logos
\usepackage{fancyhdr}% logo para cabecalhos
\usepackage{hyperref} % Utilizacao de links
\usepackage{caption}
\usepackage{subcaption}

%------------------- Comandos ---------------------%
\renewcommand{\headheight}{0.6in}
\setlength{\headwidth}{\textwidth}
\fancyhead[L]{}% empty left
\fancyhead[L]{ % right
   \includegraphics[height=0.53in]{/Users/axelferreira/Dropbox/uMinho/relatorio/logo-ee.jpg} % LOGO Cabeçalhho
}
\pagestyle{fancy}

\setlength{\unitlength}{1mm}
\newcommand\BackgroundPic[3]{
\put(#2,#3){\parbox[b][\paperheight]{\paperwidth}{
\vfill
\centering
\includegraphics{#1}
\vfill
}}}

%-------------------- Documento ------------------%
\begin{document}
%--- Logo Capa ---%
\AddToShipoutPicture*{\BackgroundPic{/Users/axelferreira/Dropbox/uMinho/relatorio/logo_eeng}{-210}{370}} % LOGO CAPA

%\includegraphics[width=100pt]{axel.jpg}
%\AddToShipoutPicture*{\BackgroundPic{axel.jpg[30pt]}{150}{-150}} % LOGO CAPA

\title{Projecto Java de Laboratório de Informática\\Relatório}
\author{Discentes:\\Axel Ferreira - a53064\\João Rua - a41841\\ \vspace{5pt}\\ Docentes:\\ F. Mário Martins\\João Miguel Fernandes\\João Luís Sobral  \vspace{20pt}}
\date{\today}

\maketitle
\vspace{40pt}

\centering

%\begin{figure}[h]
%\section{Grupo}
	\centering \huge Grupo\\ \vspace{20pt}
	\vspace{20pt}
	\begin{figure}[h]
	%	\hspace{20pt}
	        \begin{subfigure}[b]{0.30\textwidth}
	                \centering
	                \includegraphics[width=\textwidth]{axel.jpg}
		       \caption{nome : Axel Ferreira \\
				    número : 53064 \\
				    mail : axelferreira@me.com \\}
	                \label{fig:gull}
	        \end{subfigure}
		\hfill
		  \begin{subfigure}[b]{0.30\textwidth}
	                \centering
	                \includegraphics[width=\textwidth]{joao.jpg}
		       \caption{nome : João Rua \\
				    número : 41841 \\
				    mail : joaorua@gmail.com \\}
	                \label{fig:gull}
	        \end{subfigure}
		\hfill
	    %    \hspace{20pt}
	        %	        	\caption{Pictures of animals}\label{fig:animals}
	\end{figure}
%\end{figure}
\large
\newpage
\tableofcontents
%\newpage
%%%%%%%%%%%%%%%%%%%%  ABSTRACT  %%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
	
	Foi desenvolvido um programa no âmbito da U.C. de Laboratório de Informática III , capaz de utilizar o conteúdo processado pelo pelo anterior programa desenvolvido em C, também nesta UC, capaz de ler um ficheiro contendo um conjunto de autores e respetivos co-autores, e responder a alguns queries interativos sobre estes dados. Estes dados de autorias, e co-autorias são retirados do website \href{www.dblp.org}{\underline{DBLP}}.
		
\end{abstract}

%%%%%%%%%%%%%%%%%%%%  INTRODUCAO  %%%%%%%%%%%%%%%%%%%%%%
\section{Introdução}
	No âmbito da unidade curricular Laboratórios de Informática III foi proposta a realização de um projeto que dá continuidade ao projeto anteriormente desenvolvido em C nesta mesma UC. Este novo projeto conta com essencialmente duas partes.
	A primeira diz respeito á leitura de dados de memória secundária e população de estruturas de dados em memória central, gravação destas estruturas de dados em memória persistente em modo binário, bem como a criação de alguns queries de forma a permitir uma consulta interativa aos dados.
	Desenvolveram-se ainda alguns métodos que permitem consultas sobre as estruturas de dados.
	A Segunda parte prevê o teste de performance do código e respetivas estruturas de dados criados na 1ª parte, relativamente a estruturas de dados alternativas.
	De forma a facilitar esta segunda parte, o grupo teve o cuidado de criar uma interface cada vez que foi utilizada uma estrutura de dados do Java.Collections, de forma a permitir alterar as estruturas utilizadas alterando apenas, e se necessário, esta interface.
	
		
	%%%%%%%%%%%%%%%%%%     ESTRUTUA DO RELATORIO     %%%%%%%%%%%%%%
	\subsection{Estrutura do Relatório}
		Este relatório inicia-se com uma capa, incluindo o título do projeto, a data, a identificação dos autores e da equipa docente que acompanhou o projeto. Segue-se o Índice, o Abstract que resume o projeto, a Introdução ao mesmo (onde se explicita o objetivo a atingir) e a Estrutura do Relatório. 
		
	
	%%%%   <---------------CONTINUAR
		%%% BLA BLA BLA BLA BLA
		%O Desenvolvimento tem como secções os tipos e estruturas de dados, cada uma das tarefas Fase 1, Fase 2A e Fase 2B. Por fim apresentam-se a Conclusão e os anexos.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%      ESTRUTURAS & TIPOS DE DADOS     %%%%%%%%%%%%%%%%
\section{Classes e Estruturas de Dados}
		%%%%%%%%%%%%%%%%%%     TIPOS DE DADOS     %%%%%%%%%%%%%%%%%
		\subsection{Classes Criadas}
		
		
		Na criação deste programa foram desenvolvidas algums classes
		
		\begin{itemize}
			\item Anos - Esta classe armazena toda a estrutura de dados. Contém um TreeMap em que são inseridos todos os anos. Cada ano é inserido, utilizando como chave a String contendo a numeração do ano.
			A escolha do TreeMap deveu-se ao facto de manter a ordem do ano. Esta ordem facilita a impressão e travessia ordenada necessária para algumas queries.
				\begin{verbatim}
					private TreeMap<String,Ano> anos; 
				\end{verbatim}
			\item Ano - Classe criada para guardar o conteúdo de cada Ano, contém uma String com o nome do ano e um HashMap com os Autores. Cada autor é inserido utilizando como chave a String com o nome do mesmo.
			A utilização do HashMap deve-se ao facto de não haver vantagem associada á ordem de armazenamento.
				\begin{verbatim}
					private String ano;
					private HashMap<String,Autor> autores;
				\end{verbatim}
			\item Autor - Classe criada para guardar o nome do Autor, numero de publicações, e rede de co-autores. Esta última é armazenada num HashMap de co-autores. Cada co-autor é inserido utilizando como chave a String com o nome do mesmo.
			A utilização do HashMap deve-se ao facto de não haver vantagem associada á ordem de armazenamento.
				\begin{verbatim}
					private String nome;
					private int artigos;
					private HashMap<String,Coautores> coautores;
				\end{verbatim}
			\item Coautor - Classe criada para guardar o conteúdo de cada co-autor, resumindo-se ao nome e numero de artigos publicados em comum com o respetivo autor.
				\begin{verbatim}
					private String nome;
					private int artigos;
				\end{verbatim}
			\item FileInput - Esta classe faz todo o parsing e leitura dos dados de ficheiros com que posteriormente as estruturas de dados são povoadas. Contém apenas como variável de classe o nome do ficheiro que deve ler sempre.
			Contém ainda um método de classe que devolve o nome do ficheiro.
			Bem como dois métodos que devolvem o conteúdo dos ficheiros.
				\begin{verbatim}
					public static final String ficheiro ="publicx.txt";			
				\end{verbatim}

		\end{itemize}
				
		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%   Consultas Dados  70%      %%%%%%%%%%%%%%%%%%%%
\section{Consultas Estatísticas}
	\subsection{Dados do último ficheiro lido}
		Quando o ficheiro é lido, é apresentado no ecrã o nome do ficheiro, seguido do número total de artigos, e número total de nomes lidos, número total de nomes distintos bem como o intervalo fechado de anos em que os artigos foram lidos.
		É ainda apresentada alguma informação respeitante aos dados atuais da estrutura de dados, nomeadamente nº total de autores, nº total de artigos, de um só autor, e nº de autores que apenas publicaram a solo.
		Finalmente é ainda apresentada toda a sequência ordenada de anos seguido do respetivo número de publicações.
	\subsection{Consultas Interativas}
\section{Consultas Interativas}
	\subsection{}				
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     Mediadas de Performance 30%    %%%%%%%%%%%%%%%%%%%%
\section{Medidas de Performance}

		Nesta fase foi efetuado o refactoring e implementado o buffer dinâmico. Garantindo-se desta forma que o fluxo do programa é centrado no main e que o buffer tem sempre tamanho suficiente para ler uma linha.
		
		
		
		% ANALISE DO TEMPO DE EXECUÇÂO MC - PC - CM

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%     Modularidade     %%%%%%%%%%%%%%%%%%%%			
\section{Modularidade}
			Após a primeira entrega, de forma a garantir a ocultação de dados e da implementação, a abstração de dados, o encapsulamento e alguma independência contextual, a arquitetura do programa sofreu um processo de refactoring tendo sido reformulados e criados novos módulos. Em cada módulo, os dados foram declarados como "static" tendo sido criados interfaces para mediar o manuseamento dos mesmos. Isto garante independência contextual, ocultação da implementação e dos dados. Estas interfaces foram posteriormente incluídas no programa main de forma a garantir que todo o fluxo do programa é controlado pelo módulo main.
			é possível ver a nova arquitetura dos módulos no diagrama abaixo.
			\includegraphics[width=\textwidth]{Arquitetura.jpg}
			Toda a criação do programa, alteração e implementações experimentais foram feitas com recurso ao git com repositório no Github. O que permitiu a criação de branches para cada parte do projeto, bem como para experiências. \\
			\includegraphics[width=.5\textwidth]{branch.jpg}\\
			Para além disto também foi com recurso ao Git que foi possível a compilação de uma versão pré-refactoring para comparação da performance.
						
			\subsection{parser} O módulo Parser é responsável pelo parsing e validação de cada linha que lhe é passada. devolvendo uma estrutura Stats contendo a informação relevante da linha (nomes de autores, número de autores e ano da publicação) caso seja válida.
			
			\subsection{fread} O módulo fread (file read) é responsável pela abertura de ficheiros para leitura. Está preparado para trabalhar com um número de ficheiros máximo a definir na interface. Este módulo está preparado para trabalhar com múltiplos ficheiros simultaneamente devido a duas razões. A primeira é para permitir que este módulo possa trabalhar com o ficheiro lista.txt e com um ficheiro de revista ou conferencia em simultâneo. A segunda razão deve-se a inicialmente ter sido pensada a possibilidade de otimizar o programa através da criação de várias threads de forma a que cada ficheiro de revista ou conferência pudesse ser tratado num processo separado, implementando assim paralelismo. 
			Contudo no decorrer do projeto, e após medições te tempos de execução tanto no teste 5 (stress) como posteriormente no TESTE1\_FASE2, foi concluído que esta otimização era desnecessária tendo em conta o tempo que a implementação gastaria, bem como o pouco benefício (em tempo de execução) que traria. Esta conclusão é suportada pelo facto dos testes utilizados terem dimensões razoavelmente grandes e o tempo de execução nestes testes anda na ordem das décimas de segundo tal como nos testes mais simples.
			Inicialmente foi implementado um buffer de 1KB, tendo sido alterado posteriormente para um buffer dinâmico em que o tamaho inicial deste buffer é ligeiramente superior á dimensão da maioria do tamanho das entradas.
			
			\includegraphics[width=\textwidth]{grafo.jpg}
			
			\subsection{fwrite}
			Este módulo é semelhante ao anterior, difere apenas no propósito de escrever ficheiros.
			\subsection{F}
			O módulo F consiste na implementação da fase 2A, possui uma interface que é utilizada pelo módulo main de forma a inserir os dados relevantes que o main recebe através do módulo parser. O módulo F é responsável pela criação e gestão da estrutura de dados que permite posteriormente imprimir o ficheiro G.
			\subsection{main}
			Este módulo controla o fluxo do programa, fazendo a ponte entre os módulos anteriores. Nomeadamente faz um pedido de linha do ficheiro lista.txt ao modulo fread, para cada linha devolvida faz um novo pedido a esse módulo com o nome de cada ficheiro, sendo devolvida cada linha (entrada) deste último ficheiro. Posteriormente o main passa a linha obtida ao parser, de onde é devolvido um resultado que pode ser NULL sendo incrementado o contador de artigos rejeitados (static no main) ou uma estrutura com informação que é passada ao módulo F para inserção. Finalmente, quando todos os ficheiros contidos no ficheiro "lista.txt" forem processados, o módulo main dá ordem de impressão dos ficheiros D.txt, E.txt e G.csv aos respetivos módulos.
			
\section{Conclusão}
		
		A principal dificuldade que foi ultrapassada, nomeadamente na 2ª Fase, foi a implementação das estruturas de dados uma vez que a função de inserção não funcionava corretamente tendo sido re implementada numa versão recursiva correta. A dificuldade não ultrapassada devido, ao tempo despendido no processo de refactoring, resume-se á falta de tempo para implementação da estrutura de co-autoria. 

\section{Interface}
\begin{itemize}
	\item Parser
		\begin{verbatim}
		 /**
		 * Patses a Line 
		 * @param buffer the buffer containing the line to be parsed
		 * @param ty+he type of the line conference or jounal)
		 * @return Struct with all counters.
		 */
		Stats parseLine(char * buffer, char t);
		\end{verbatim}
		
	\item fread
		\begin{verbatim}
		 /**
		 * Initializes the control for the files
		 */
		void init_file_control();
		
		/**
		 * Opens a file.
		 * @return file index in control, or -1 if failed.
		 */
		int openFile(char * file_name, char * mode);
		
		/**
		 * Reads a line from a file growing the buffer as needed.
		 * @param a reference to the buffer reference.
		 * @param a reference for the size of the buffer.
		 * @param file index in control.
		 * @return 0 if success -1 otherwise.
		 */
		int dynamic_read_line(char** buf, int* size, int file);
		
		/**
		 * Closes a file.
		 * @param index of the file to be closed.
		 */
		void closeFile(int index);
		\end{verbatim}
	\item fwrite
		\begin{verbatim}
		/**
		 * This function outputs the number of rejected entries in each file to the "E.txt" file. If the file does not exist, it is created.
		 * @param int counter number of invalid entries in the file.
		 * @param char * fileN the name of the courent file.
		 */
		void imprimeE(int bool, int counter, char * file, char * path);

		/**
		 * This function creates the file "D.txt" and it's content. If the file alreaddy exists, it is rewritten.
		 * @param nRej the number of rejected entries
		 * @param nJou the number of Journals
		 * @param nCou the number of Counferences
		 * @param path the path of the file to be written to.
		 */
		void imprimeD(int nRej, int nJou, int nCou, char * path);
		\end{verbatim}
	\item F
		\begin{verbatim}
		/**
		 * Adds data to the structure.
		 * @return returns a pointer to a structure with the linked list
		 */
		struct sList * addList();
		
		/**
		 * This function creates the file "G.csv" and it's content. If the file alreaddy exists it is rewritten.
		 * @param bool if it's first time opens in "w" mode else in "a".
		 */
		int imprimeG();
		\end{verbatim}
		
\end{itemize}		
		
	
\end{document}